TASK: Debug why for loop exits immediately after ((CURRENT++))

BREAKTHROUGH: Loop is NOW EXECUTING (was completely blocked before)

SYMPTOM:
- set -x trace shows:
  + for folder in "${FOLDERS_TO_TRANSFER[@]}"
  + (( CURRENT++ ))          ✅ SUCCEEDS
  + cleanup                  ❌ EXITS HERE

- Script NEVER reaches SOURCE_PATH="$NAS_MOUNT_POINT/$folder" line
- Cleanup trap fires with exit_code=1
- Log shows all debug messages before loop, then cleanup

CODE SEQUENCE (lines 250-267 approx):
```bash
log_info "DEBUG: About to calculate TOTAL_FOLDERS"
TOTAL_FOLDERS=${#FOLDERS_TO_TRANSFER[@]}  # Shows 4
log_info "DEBUG: TOTAL_FOLDERS=$TOTAL_FOLDERS"
log_info "DEBUG: FOLDERS_TO_TRANSFER has 4 elements"

CURRENT=0
log_info "DEBUG: Starting for loop with array: ${FOLDERS_TO_TRANSFER[*]}"

set -x  # Enable tracing HERE
for folder in "${FOLDERS_TO_TRANSFER[@]}"; do
    ((CURRENT++))                           # This executes!
    SOURCE_PATH="$NAS_MOUNT_POINT/$folder" # This does NOT appear in trace!
    DEST_PATH="$TARGET_PATH/$folder"        # Never reached
    
    {
        echo ""
        echo "╔═══════════════════════════════════════════════════════════════╗"
        echo "║ Transfer: $folder [$CURRENT/$TOTAL_FOLDERS]"
```

CRITICAL QUESTION:
What could cause the script to exit with code 1 BETWEEN:
  ((CURRENT++))  [succeeds]
  AND
  SOURCE_PATH="$NAS_MOUNT_POINT/$folder"  [never executes]

CONTEXT:
- set -euo pipefail is active
- NAS_MOUNT_POINT="/mnt/920-filmy920" (verified in STEP 3)
- folder="2022" (first loop iteration, verified in debug output)
- The expansion ${FOLDERS_TO_TRANSFER[@]} works (loop starts)

POSSIBILITIES:
1. Variable expansion issue with $NAS_MOUNT_POINT or $folder?
2. Shell syntax issue with variable assignment in loop?
3. Some other command between lines that isn't visible?
4. Issue with how set -x is capturing trace?
5. Something in the brace block {...} execution?

Ask Gemini: Why would a simple variable assignment fail here?
